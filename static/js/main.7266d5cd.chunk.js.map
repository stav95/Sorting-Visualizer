{"version":3,"sources":["logo.svg","Visualizer/Node.jsx","algorithms/dijkstra.js","algorithms/dfs.js","Visualizer/Visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","row","col","isStart","isDestination","onMouseDown","onMouseUp","onMouseEnter","onClick","id","className","React","Component","dijkstra","graph","start_location","destination_location","withAnimation","LOCK_CONTROLS","numberOfCols","i","length","parseInt","node","startIndex","getIndexByRowCol","distance","previous","visited","initialGraph","nodesToVisit","push","solveNeighbors","countTime","tickValue","saveDestinationTime","shift","createVisitedAnimation","indexDestination","setTimeout","Infinity","path","reverse","getRowColByIndex","document","getElementById","classList","remove","add","createPathAnimation","Math","max","currentNodeIndex","currentNode","neighbors","idx","tmpCol","abs","isWall","includes","getNeighbors","nodes","neighbor","weight","sort","n1","n2","index","SPEED_ANIMATION","dfs","makeMove","timeCounter","isDone","r","c","ele","getElementsByClassName","isFinish","contains","destinationNodeIndex","START_LOCATION_ROW","START_LOCATION_COL","DESTINATION_LOCATION_ROW","DESTINATION_LOCATION_COL","BLOCK_LIST","DRAW_WALLS","DRAW_START_POINT","DRAW_DESTINATION_POINT","Visualizer","state","grid","createNewGrid","setState","nodes_count_col","floor","window","innerWidth","nodes_count_row","innerHeight","obj","createNewNode","is_start_destination_point","is_in_block_list","mouseEnterDrawWalls","mouseEnterDrawPoint","isStartPoint","is_start_point","is_destination_point","clearWalls","clearPath","randomStartLocation","randomDestinationLocation","createRandomWalls","canBeSolved","generateRandomMaze","maxRow","getAttribute","maxCol","generateInteger","how_many","min","random","style","fontSize","cursor","solveWithDijkstra","solveWithBFS","solveWithDFS","map","rowIdx","key","nodeIdx","mouseIsDown","mouseIsUp","mouseEnter","mouseClick","color","lock_controls","createGraph","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7266d5cd.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends React.Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isDestination,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter,\r\n      onClick\r\n    } = this.props;\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        row={row}\r\n        col={col}\r\n        className={`node ${isStart ? \"start\" : \"\"}${\r\n          isDestination ? \"destination\" : \"\"\r\n        }`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onClick={() => onClick(row, col)}\r\n      />\r\n    );\r\n  }\r\n}\r\n","/*  graph.push({\r\n        node: {\r\n          row: node.getAttribute(\"row\"),\r\n          col: node.getAttribute(\"col\"),\r\n          isWall: node.classList.contains(\"wall\"),\r\n          isStart: node.classList.contains(\"start\"),\r\n          isDestination: node.classList.contains(\"destination\"),\r\n          weight: 1,\r\n          distance: Infinity,\r\n          previous: null\r\n        }\r\n      }); */\r\n\r\nexport function dijkstra(\r\n  graph,\r\n  start_location,\r\n  destination_location,\r\n  withAnimation,\r\n  LOCK_CONTROLS\r\n) {\r\n  let { visited, numberOfCols, startIndex } = initialGraph(\r\n    graph,\r\n    start_location\r\n  );\r\n\r\n  const nodesToVisit = [];\r\n\r\n  nodesToVisit.push(\r\n    ...solveNeighbors(\r\n      graph,\r\n      start_location.row,\r\n      start_location.col,\r\n      numberOfCols,\r\n      visited\r\n    )\r\n  );\r\n\r\n  let countTime = 10;\r\n  let tickValue = 10;\r\n  let saveDestinationTime = countTime;\r\n  while (nodesToVisit.length > 0) {\r\n    const { row, col } = nodesToVisit.shift().node;\r\n    if (withAnimation) {\r\n      countTime = createVisitedAnimation(\r\n        destination_location,\r\n        row,\r\n        col,\r\n        countTime,\r\n        tickValue\r\n      );\r\n\r\n      if (destination_location.row == row && destination_location.col == col) {\r\n        saveDestinationTime = countTime + 500;\r\n        tickValue = 2;\r\n      }\r\n    }\r\n\r\n    visited.push(getIndexByRowCol(numberOfCols, row, col));\r\n\r\n    nodesToVisit.push(\r\n      ...solveNeighbors(graph, row, col, numberOfCols, visited)\r\n    );\r\n  }\r\n\r\n  let indexDestination = getIndexByRowCol(\r\n    numberOfCols,\r\n    destination_location.row,\r\n    destination_location.col\r\n  );\r\n\r\n  if (withAnimation) {\r\n    const path = [];\r\n\r\n    if (graph[indexDestination].node.distance !== Infinity) {\r\n      while (graph[indexDestination].node.previous !== startIndex) {\r\n        path.push(graph[indexDestination].node.previous);\r\n        indexDestination = graph[indexDestination].node.previous;\r\n      }\r\n\r\n      path.reverse();\r\n\r\n      saveDestinationTime = createPathAnimation(\r\n        path,\r\n        numberOfCols,\r\n        saveDestinationTime\r\n      );\r\n\r\n      setTimeout(() => {\r\n        LOCK_CONTROLS[0] = false;\r\n      }, Math.max(countTime, saveDestinationTime));\r\n    }\r\n  } else {\r\n    setTimeout(() => {\r\n      LOCK_CONTROLS[0] = false;\r\n    }, countTime);\r\n\r\n    return graph[indexDestination].node.distance !== Infinity;\r\n  }\r\n}\r\n\r\nfunction initialGraph(graph, start_location) {\r\n  let numberOfCols = 0;\r\n\r\n  for (let i = 0; i < graph.length; i++)\r\n    if (parseInt(graph[i].node.row) === 0) numberOfCols++;\r\n\r\n  let startIndex = getIndexByRowCol(\r\n    numberOfCols,\r\n    start_location.row,\r\n    start_location.col\r\n  );\r\n\r\n  graph[startIndex].node.distance = 0;\r\n  graph[startIndex].node.previous = -1;\r\n\r\n  const visited = [startIndex];\r\n\r\n  return {\r\n    visited,\r\n    numberOfCols,\r\n    startIndex\r\n  };\r\n}\r\n\r\nfunction createVisitedAnimation(\r\n  destination_location,\r\n  row,\r\n  col,\r\n  countTime,\r\n  tickValue\r\n) {\r\n  setTimeout(() => {\r\n    if (destination_location.row != row || destination_location.col != col) {\r\n      document.getElementById(`node-${row}-${col}`).classList.add(\"visited\");\r\n    }\r\n  }, countTime);\r\n  return countTime + tickValue;\r\n}\r\n\r\nfunction createPathAnimation(path, numberOfCols, saveDestinationTime) {\r\n  for (let i = 0; i < path.length; i++) {\r\n    const { row, col } = getRowColByIndex(numberOfCols, path[i]);\r\n\r\n    setTimeout(() => {\r\n      document.getElementById(`node-${row}-${col}`).classList.remove(\"visited\");\r\n      document.getElementById(`node-${row}-${col}`).classList.add(\"path\");\r\n    }, saveDestinationTime);\r\n\r\n    saveDestinationTime += 50;\r\n  }\r\n\r\n  return saveDestinationTime;\r\n}\r\n\r\nfunction solveNeighbors(graph, row, col, numberOfCols, visited) {\r\n  const currentNodeIndex = getIndexByRowCol(numberOfCols, row, col);\r\n  const currentNode = graph[currentNodeIndex].node;\r\n  const neighbors = getNeighbors(graph, visited, row, col, numberOfCols);\r\n\r\n  const nodes = [];\r\n  for (let i = 0; i < neighbors.length; i++) {\r\n    const neighbor = graph[neighbors[i]].node;\r\n\r\n    if (neighbor.distance > currentNode.distance + neighbor.weight) {\r\n      neighbor.distance = currentNode.distance + neighbor.weight;\r\n      neighbor.previous = currentNodeIndex;\r\n\r\n      nodes.push({ node: graph[neighbors[i]].node });\r\n    }\r\n  }\r\n\r\n  nodes.sort((n1, n2) => n1.node.distance - n2.node.distance);\r\n  return nodes;\r\n}\r\n\r\nfunction getNeighbors(graph, visited, row, col, numberOfCols) {\r\n  row = parseInt(row);\r\n  col = parseInt(col);\r\n  numberOfCols = parseInt(numberOfCols);\r\n  const neighbors = [];\r\n\r\n  let idx = getIndexByRowCol(numberOfCols, row, col + 1);\r\n  const tmpCol = getRowColByIndex(numberOfCols, idx).col; //used to check that our algo wont go from right border to left border as a step\r\n  if (\r\n    Math.abs(tmpCol - col) <= 1 &&\r\n    graph.length > idx &&\r\n    !graph[idx].node.isWall &&\r\n    !visited.includes(idx)\r\n  ) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row, col - 1);\r\n  if (col - 1 >= 0 && !visited.includes(idx) && !graph[idx].node.isWall) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row + 1, col);\r\n  if (graph.length > idx && !visited.includes(idx) && !graph[idx].node.isWall) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row - 1, col);\r\n  if (row - 1 >= 0 && !visited.includes(idx) && !graph[idx].node.isWall) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nfunction getIndexByRowCol(numberOfCols, row, col) {\r\n  return parseInt(row) * parseInt(numberOfCols) + parseInt(col);\r\n}\r\n\r\nfunction getRowColByIndex(numberOfCols, index) {\r\n  let col = index % numberOfCols;\r\n  index -= col;\r\n\r\n  return { row: index / numberOfCols, col: col };\r\n}\r\n","/*  graph.push({\r\n        node: {\r\n          row: node.getAttribute(\"row\"),\r\n          col: node.getAttribute(\"col\"),\r\n          isWall: node.classList.contains(\"wall\"),\r\n          isStart: node.classList.contains(\"start\"),\r\n          isDestination: node.classList.contains(\"destination\"),\r\n          weight: 1,\r\n          distance: Infinity,\r\n          previous: null\r\n        }\r\n      }); */\r\n\r\nlet SPEED_ANIMATION = 10;\r\n\r\nexport function dfs(\r\n  graph,\r\n  start_location,\r\n  destination_location,\r\n  LOCK_CONTROLS\r\n) {\r\n  let { visited, numberOfCols, startIndex } = initialGraph(\r\n    graph,\r\n    start_location\r\n  );\r\n\r\n  SPEED_ANIMATION = 10;\r\n\r\n  let { row, col } = start_location;\r\n  makeMove(graph, visited, row, col, numberOfCols);\r\n\r\n  let timeCounter = 50;\r\n  let isDone = false;\r\n  let saveDestinationTime = null;\r\n  for (let i = 0; i < visited.length; i++) {\r\n    const node = graph[visited[i]].node;\r\n    const r = parseInt(node.row);\r\n    const c = parseInt(node.col);\r\n\r\n    const ele = document.getElementById(`node-${r}-${c}`);\r\n    setTimeout(() => {\r\n      isDone = isFinish();\r\n      if (!isDone) {\r\n        ele.classList.remove(\"visited\");\r\n      }\r\n    }, timeCounter);\r\n    timeCounter += SPEED_ANIMATION;\r\n    setTimeout(() => {\r\n      if (\r\n        !ele.classList.contains(\"start\") &&\r\n        !ele.classList.contains(\"destination\") &&\r\n        !isDone\r\n      ) {\r\n        ele.classList.add(\"visited\");\r\n      }\r\n    }, timeCounter);\r\n\r\n    if (node.isDestination) {\r\n      SPEED_ANIMATION = 2;\r\n      if (saveDestinationTime === null) {\r\n        saveDestinationTime = timeCounter;\r\n      }\r\n    }\r\n\r\n    timeCounter += SPEED_ANIMATION;\r\n  }\r\n\r\n  let destinationNodeIndex = getIndexByRowCol(\r\n    numberOfCols,\r\n    destination_location.row,\r\n    destination_location.col\r\n  );\r\n\r\n  if (graph[destinationNodeIndex].node.distance !== Infinity) {\r\n    const path = [];\r\n    while (graph[destinationNodeIndex].node.previous !== startIndex) {\r\n      path.push(graph[destinationNodeIndex].node.previous);\r\n      destinationNodeIndex = graph[destinationNodeIndex].node.previous;\r\n    }\r\n\r\n    path.reverse();\r\n\r\n    saveDestinationTime = createPathAnimation(\r\n      path,\r\n      numberOfCols,\r\n      saveDestinationTime\r\n    );\r\n  }\r\n\r\n  setTimeout(() => {\r\n    LOCK_CONTROLS[0] = false;\r\n  }, Math.max(timeCounter, saveDestinationTime));\r\n}\r\n\r\n//cloned\r\nfunction initialGraph(graph, start_location) {\r\n  let numberOfCols = 0;\r\n\r\n  for (let i = 0; i < graph.length; i++)\r\n    if (parseInt(graph[i].node.row) === 0) numberOfCols++;\r\n\r\n  let startIndex = getIndexByRowCol(\r\n    numberOfCols,\r\n    start_location.row,\r\n    start_location.col\r\n  );\r\n\r\n  graph[startIndex].node.distance = 0;\r\n  graph[startIndex].node.previous = -1;\r\n\r\n  const visited = [startIndex];\r\n\r\n  return {\r\n    visited,\r\n    numberOfCols,\r\n    startIndex\r\n  };\r\n}\r\n\r\nfunction createPathAnimation(path, numberOfCols, saveDestinationTime) {\r\n  for (let i = 0; i < path.length; i++) {\r\n    const { row, col } = getRowColByIndex(numberOfCols, path[i]);\r\n\r\n    setTimeout(() => {\r\n      document.getElementById(`node-${row}-${col}`).classList.remove(\"visited\");\r\n      document.getElementById(`node-${row}-${col}`).classList.add(\"path\");\r\n    }, saveDestinationTime);\r\n\r\n    saveDestinationTime += 50;\r\n  }\r\n\r\n  return saveDestinationTime;\r\n}\r\n\r\nfunction isFinish() {\r\n  const nodes = document.getElementsByClassName(\"node\");\r\n\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    if (nodes[i].classList.length === 1) return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction makeMove(graph, visited, row, col, numberOfCols) {\r\n  const neighbors = getNeighbors(graph, visited, row, col, numberOfCols);\r\n  const currentNodeIndex = getIndexByRowCol(numberOfCols, row, col);\r\n  for (let i = 0; i < neighbors.length; i++) {\r\n    if (visited.includes(neighbors[i])) {\r\n      continue;\r\n    }\r\n    visited.push(neighbors[i]);\r\n\r\n    let node = graph[neighbors[i]].node;\r\n    node.previous = currentNodeIndex;\r\n    node.distance = graph[currentNodeIndex].node.distance + 1;\r\n    const { row, col } = node;\r\n\r\n    makeMove(graph, visited, row, col, numberOfCols);\r\n    visited.push(neighbors[i]);\r\n  }\r\n}\r\n\r\nfunction getNeighbors(graph, visited, row, col, numberOfCols) {\r\n  row = parseInt(row);\r\n  col = parseInt(col);\r\n  numberOfCols = parseInt(numberOfCols);\r\n  const neighbors = [];\r\n\r\n  let idx = getIndexByRowCol(numberOfCols, row, col + 1);\r\n  const tmpCol = getRowColByIndex(numberOfCols, idx).col; //used to check that our algo wont go from right border to left border as a step\r\n  if (\r\n    Math.abs(tmpCol - col) <= 1 &&\r\n    graph.length > idx &&\r\n    !graph[idx].node.isWall &&\r\n    !graph[idx].node.isStart &&\r\n    !visited.includes(idx)\r\n  ) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row, col - 1);\r\n  if (\r\n    col - 1 >= 0 &&\r\n    !visited.includes(idx) &&\r\n    !graph[idx].node.isWall &&\r\n    !graph[idx].node.isStart\r\n  ) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row + 1, col);\r\n  if (\r\n    graph.length > idx &&\r\n    !visited.includes(idx) &&\r\n    !graph[idx].node.isWall &&\r\n    !graph[idx].node.isStart\r\n  ) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  idx = getIndexByRowCol(numberOfCols, row - 1, col);\r\n  if (\r\n    row - 1 >= 0 &&\r\n    !visited.includes(idx) &&\r\n    !graph[idx].node.isWall &&\r\n    !graph[idx].node.isStart\r\n  ) {\r\n    neighbors.push(idx);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n//cloned\r\nfunction getIndexByRowCol(numberOfCols, row, col) {\r\n  return parseInt(row) * parseInt(numberOfCols) + parseInt(col);\r\n}\r\n\r\n//cloned\r\nfunction getRowColByIndex(numberOfCols, index) {\r\n  let col = index % numberOfCols;\r\n  index -= col;\r\n\r\n  return { row: index / numberOfCols, col: col };\r\n}\r\n","import React from \"react\";\r\nimport \"./Visualizer.css\";\r\n\r\nimport Node from \"./Node\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport InputRange from \"react-input-range\";\r\nimport { dfs } from \"../algorithms/dfs\";\r\n\r\nconst NODE_WIDTH = 25 + 2; //WIDTH + BORDER\r\nconst NODE_HEIGHT = 25 + 2; //HEIGHT + BORDER\r\nconst SELECTED_ALGO_COLOR = \"khaki\";\r\n\r\nlet START_LOCATION_ROW = 10;\r\nlet START_LOCATION_COL = 20;\r\nlet DESTINATION_LOCATION_ROW = 10;\r\nlet DESTINATION_LOCATION_COL = 50;\r\n\r\nconst BLOCK_LIST = [];\r\nlet DRAW_WALLS = false;\r\nlet DRAW_START_POINT = false;\r\nlet DRAW_DESTINATION_POINT = false;\r\n\r\nlet LOCK_CONTROLS = [false];\r\n\r\nexport default class Visualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      grid: []\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.createNewGrid();\r\n    this.setState({\r\n      grid,\r\n      start_location: {\r\n        row: START_LOCATION_ROW,\r\n        col: START_LOCATION_COL\r\n      },\r\n      destination_location: {\r\n        row: DESTINATION_LOCATION_ROW,\r\n        col: DESTINATION_LOCATION_COL\r\n      }\r\n    });\r\n  }\r\n\r\n  createNewGrid() {\r\n    const nodes_count_col = Math.floor(window.innerWidth / NODE_WIDTH);\r\n    const nodes_count_row = Math.floor(\r\n      (window.innerHeight * 0.9) / NODE_HEIGHT\r\n    );\r\n\r\n    START_LOCATION_ROW = Math.floor(nodes_count_row / 2) - 1;\r\n    START_LOCATION_COL = Math.floor(nodes_count_col / 4);\r\n\r\n    DESTINATION_LOCATION_COL = Math.floor(nodes_count_col / 4) * 3;\r\n    DESTINATION_LOCATION_ROW = Math.floor(nodes_count_row / 2) - 1;\r\n\r\n    const grid = [];\r\n    for (let row = 0; row < nodes_count_row; row++) {\r\n      const obj = [];\r\n      for (let col = 0; col < nodes_count_col; col++) {\r\n        obj.push(this.createNewNode(row, col));\r\n      }\r\n\r\n      grid.push(obj);\r\n    }\r\n\r\n    return grid;\r\n  }\r\n\r\n  createNewNode(row, col) {\r\n    return {\r\n      row,\r\n      col\r\n    };\r\n  }\r\n\r\n  mouseIsDown(row, col) {\r\n    if (this.is_start_destination_point(row, col)) {\r\n      return;\r\n    }\r\n\r\n    DRAW_WALLS = true;\r\n\r\n    if (this.is_in_block_list(row, col)) {\r\n      return;\r\n    }\r\n\r\n    let ele = document.getElementById(`node-${row}-${col}`);\r\n\r\n    if (ele.classList.contains(\"wall\")) {\r\n      ele.classList.remove(\"wall\");\r\n    } else {\r\n      BLOCK_LIST.push({ row, col });\r\n      ele.classList.add(\"wall\");\r\n\r\n      setTimeout(() => {\r\n        BLOCK_LIST.shift();\r\n      }, 3000); /* connects to the animation by 3sec */\r\n    }\r\n  }\r\n\r\n  mouseIsUp() {\r\n    DRAW_WALLS = false;\r\n  }\r\n\r\n  mouseEnter(row, col) {\r\n    if (DRAW_WALLS) {\r\n      this.mouseEnterDrawWalls(row, col);\r\n    } else if (DRAW_START_POINT) {\r\n      this.mouseEnterDrawPoint(row, col, true);\r\n    } else if (DRAW_DESTINATION_POINT) {\r\n      this.mouseEnterDrawPoint(row, col, false);\r\n    }\r\n  }\r\n\r\n  mouseEnterDrawWalls(row, col) {\r\n    if (this.is_in_block_list(row, col)) {\r\n      return;\r\n    }\r\n\r\n    let ele = document.getElementById(`node-${row}-${col}`);\r\n\r\n    if (ele.classList.contains(\"wall\")) {\r\n      ele.classList.remove(\"wall\");\r\n    } else {\r\n      BLOCK_LIST.push({ row, col });\r\n      ele.classList.add(\"wall\");\r\n\r\n      setTimeout(() => {\r\n        BLOCK_LIST.shift();\r\n      }, 3000);\r\n    }\r\n  }\r\n\r\n  mouseEnterDrawPoint(row, col, isStartPoint) {\r\n    if (isStartPoint) {\r\n      document\r\n        .getElementById(`node-${START_LOCATION_ROW}-${START_LOCATION_COL}`)\r\n        .classList.remove(\"start\", \"red\");\r\n      document\r\n        .getElementById(`node-${row}-${col}`)\r\n        .classList.add(\"start\", \"red\");\r\n\r\n      START_LOCATION_ROW = row;\r\n      START_LOCATION_COL = col;\r\n    } else {\r\n      document\r\n        .getElementById(\r\n          `node-${DESTINATION_LOCATION_ROW}-${DESTINATION_LOCATION_COL}`\r\n        )\r\n        .classList.remove(\"destination\", \"black\");\r\n      document\r\n        .getElementById(`node-${row}-${col}`)\r\n        .classList.add(\"destination\", \"black\");\r\n\r\n      DESTINATION_LOCATION_ROW = row;\r\n      DESTINATION_LOCATION_COL = col;\r\n    }\r\n  }\r\n\r\n  is_start_destination_point(row, col) {\r\n    if (this.is_start_point(row, col) || this.is_destination_point(row, col))\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  is_start_point(row, col) {\r\n    if (row === START_LOCATION_ROW && col === START_LOCATION_COL) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  is_destination_point(row, col) {\r\n    if (row === DESTINATION_LOCATION_ROW && col === DESTINATION_LOCATION_COL) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  is_in_block_list(row, col) {\r\n    for (let i = 0; i < BLOCK_LIST.length; i++)\r\n      if (BLOCK_LIST[i].row === row && BLOCK_LIST[i].col === col) {\r\n        return true;\r\n      }\r\n\r\n    return this.is_start_destination_point(row, col);\r\n  }\r\n\r\n  mouseClick(row, col) {\r\n    if (DRAW_START_POINT) {\r\n      {\r\n        DRAW_START_POINT = false;\r\n        document\r\n          .getElementById(`node-${row}-${col}`)\r\n          .classList.remove(\"start\", \"red\", \"wall\", \"visited\");\r\n        document.getElementById(`node-${row}-${col}`).classList.add(\"start\");\r\n      }\r\n    } else {\r\n      if (this.is_start_point(row, col) && !DRAW_START_POINT) {\r\n        DRAW_START_POINT = true;\r\n        document.getElementById(`node-${row}-${col}`).classList.add(\"red\");\r\n      }\r\n    }\r\n\r\n    if (DRAW_DESTINATION_POINT) {\r\n      DRAW_DESTINATION_POINT = false;\r\n      document\r\n        .getElementById(`node-${row}-${col}`)\r\n        .classList.remove(\"destination\", \"black\", \"wall\", \"visited\");\r\n      document\r\n        .getElementById(`node-${row}-${col}`)\r\n        .classList.add(\"destination\");\r\n    } else {\r\n      if (this.is_destination_point(row, col) && !DRAW_DESTINATION_POINT) {\r\n        DRAW_DESTINATION_POINT = true;\r\n        document.getElementById(`node-${row}-${col}`).classList.add(\"black\");\r\n      }\r\n    }\r\n  }\r\n\r\n  generateRandomMaze() {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n\r\n    this.clearWalls();\r\n    this.clearPath();\r\n\r\n    const nodes = document.getElementsByClassName(\"node\");\r\n\r\n    this.randomStartLocation(nodes);\r\n    this.randomDestinationLocation(nodes);\r\n    this.createRandomWalls(nodes, Math.floor(nodes.length / 4));\r\n\r\n    if (!this.canBeSolved()) {\r\n      this.generateRandomMaze();\r\n    }\r\n  }\r\n\r\n  randomStartLocation(nodes) {\r\n    document\r\n      .getElementById(`node-${START_LOCATION_ROW}-${START_LOCATION_COL}`)\r\n      .classList.remove(\"start\");\r\n\r\n    let maxRow = nodes[nodes.length - 1].getAttribute(\"row\");\r\n    let maxCol = nodes[nodes.length - 1].getAttribute(\"col\");\r\n\r\n    START_LOCATION_ROW = this.generateInteger(1, parseInt(maxRow) - 1);\r\n    START_LOCATION_COL = this.generateInteger(1, parseInt(maxCol) - 1);\r\n\r\n    document\r\n      .getElementById(`node-${START_LOCATION_ROW}-${START_LOCATION_COL}`)\r\n      .classList.add(\"start\");\r\n  }\r\n\r\n  randomDestinationLocation(nodes) {\r\n    document\r\n      .getElementById(\r\n        `node-${DESTINATION_LOCATION_ROW}-${DESTINATION_LOCATION_COL}`\r\n      )\r\n      .classList.remove(\"destination\");\r\n\r\n    let maxRow = nodes[nodes.length - 1].getAttribute(\"row\");\r\n    let maxCol = nodes[nodes.length - 1].getAttribute(\"col\");\r\n\r\n    DESTINATION_LOCATION_ROW = this.generateInteger(1, parseInt(maxRow) - 1);\r\n    DESTINATION_LOCATION_COL = this.generateInteger(1, parseInt(maxCol) - 1);\r\n\r\n    document\r\n      .getElementById(\r\n        `node-${DESTINATION_LOCATION_ROW}-${DESTINATION_LOCATION_COL}`\r\n      )\r\n      .classList.add(\"destination\");\r\n  }\r\n\r\n  createRandomWalls(nodes, how_many) {\r\n    while (how_many > 0) {\r\n      let idx = this.generateInteger(0, nodes.length - 1);\r\n      let node = nodes[idx];\r\n\r\n      if (\r\n        START_LOCATION_ROW == node.getAttribute(\"row\") &&\r\n        START_LOCATION_COL == node.getAttribute(\"col\")\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        DESTINATION_LOCATION_ROW == node.getAttribute(\"row\") &&\r\n        DESTINATION_LOCATION_COL == node.getAttribute(\"col\")\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (node.classList.length === 1) {\r\n        {\r\n          node.classList.add(\"wall\");\r\n          how_many--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  generateInteger(min, max) {\r\n    // include min, max\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n  }\r\n\r\n  render() {\r\n    const grid = this.state.grid;\r\n\r\n    return (\r\n      <div>\r\n        <div id=\"top-menu\">\r\n          <div className=\"separator\"></div>\r\n          <div\r\n            className=\"element-top-menu\"\r\n            style={{ fontSize: \"25px\", cursor: \"default\" }}\r\n          >\r\n            Pathfinder Visualizer\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div className=\"separator\"></div>\r\n          <div\r\n            className=\"element-top-menu\"\r\n            onClick={() => this.generateRandomMaze()}\r\n          >\r\n            Generate Random Maze\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div className=\"element-top-menu\" onClick={() => this.clearPath()}>\r\n            Clear Path\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div className=\"element-top-menu\" onClick={() => this.clearWalls()}>\r\n            Clear Walls\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div className=\"separator\"></div>\r\n          <div className=\"separator\"></div>\r\n          <div\r\n            id=\"algoDijkstra\"\r\n            className=\"element-top-menu algo\"\r\n            onClick={() => this.solveWithDijkstra(true)}\r\n          >\r\n            Dijkstra\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div\r\n            id=\"algoBFS\"\r\n            className=\"element-top-menu algo\"\r\n            onClick={() => this.solveWithBFS(true)}\r\n          >\r\n            BFS\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n          <div\r\n            id=\"algoDFS\"\r\n            className=\"element-top-menu algo\"\r\n            onClick={() => this.solveWithDFS()}\r\n          >\r\n            DFS\r\n          </div>\r\n          <div className=\"separator\"></div>\r\n        </div>\r\n        <div id=\"grid\" className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"row\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={\r\n                        row === START_LOCATION_ROW && col === START_LOCATION_COL\r\n                          ? true\r\n                          : false\r\n                      }\r\n                      isDestination={\r\n                        row === DESTINATION_LOCATION_ROW &&\r\n                        col === DESTINATION_LOCATION_COL\r\n                          ? true\r\n                          : false\r\n                      }\r\n                      onMouseDown={(row, col) => this.mouseIsDown(row, col)}\r\n                      onMouseUp={() => this.mouseIsUp()}\r\n                      onMouseEnter={(row, col) => this.mouseEnter(row, col)}\r\n                      onClick={(row, col) => this.mouseClick(row, col)}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  lock_controls(id) {\r\n    LOCK_CONTROLS[0] = true;\r\n\r\n    document.getElementById(\"algoDijkstra\").style.color = \"\";\r\n    document.getElementById(\"algoBFS\").style.color = \"\";\r\n    document.getElementById(\"algoDFS\").style.color = \"\";\r\n\r\n    if (id != null && id.length > 0)\r\n      document.getElementById(id).style.color = SELECTED_ALGO_COLOR;\r\n  }\r\n\r\n  canBeSolved() {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n\r\n    return this.solveWithDijkstra(false);\r\n  }\r\n\r\n  clearPath() {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n\r\n    const nodes = document.getElementsByClassName(\"node\");\r\n\r\n    for (let i = 0; i < nodes.length; i++)\r\n      nodes[i].classList.remove(\"path\", \"visited\");\r\n  }\r\n\r\n  clearWalls() {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n    const nodes = document.getElementsByClassName(\"node\");\r\n\r\n    for (let i = 0; i < nodes.length; i++) nodes[i].classList.remove(\"wall\");\r\n  }\r\n\r\n  solveWithDijkstra(withAnimation) {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n\r\n    this.clearPath();\r\n\r\n    if (withAnimation) {\r\n      this.lock_controls(\"algoDijkstra\");\r\n    }\r\n\r\n    return dijkstra(\r\n      this.createGraph(),\r\n      { row: START_LOCATION_ROW, col: START_LOCATION_COL },\r\n      { row: DESTINATION_LOCATION_ROW, col: DESTINATION_LOCATION_COL },\r\n      withAnimation,\r\n      LOCK_CONTROLS\r\n    );\r\n  }\r\n\r\n  solveWithBFS(withAnimation) {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n\r\n    this.clearPath();\r\n\r\n    if (withAnimation) {\r\n      this.lock_controls(\"algoBFS\");\r\n    }\r\n\r\n    return dijkstra(\r\n      this.createGraph(),\r\n      { row: START_LOCATION_ROW, col: START_LOCATION_COL },\r\n      { row: DESTINATION_LOCATION_ROW, col: DESTINATION_LOCATION_COL },\r\n      withAnimation,\r\n      LOCK_CONTROLS\r\n    );\r\n  }\r\n\r\n  solveWithDFS() {\r\n    if (LOCK_CONTROLS[0]) {\r\n      return;\r\n    }\r\n    this.clearPath();\r\n    this.lock_controls(\"algoDFS\");\r\n\r\n    dfs(\r\n      this.createGraph(),\r\n      { row: START_LOCATION_ROW, col: START_LOCATION_COL },\r\n      { row: DESTINATION_LOCATION_ROW, col: DESTINATION_LOCATION_COL },\r\n      LOCK_CONTROLS\r\n    );\r\n  }\r\n\r\n  createGraph() {\r\n    const graph = [];\r\n    const nodes = document.getElementsByClassName(\"node\");\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n\r\n      graph.push({\r\n        node: {\r\n          row: node.getAttribute(\"row\"),\r\n          col: node.getAttribute(\"col\"),\r\n          isWall: node.classList.contains(\"wall\"),\r\n          isStart: node.classList.contains(\"start\"),\r\n          isDestination: node.classList.contains(\"destination\"),\r\n          weight: 1,\r\n          distance: Infinity,\r\n          previous: null\r\n        }\r\n      });\r\n    }\r\n\r\n    return graph;\r\n  }\r\n}\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Visualizer from './Visualizer/Visualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Visualizer></Visualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}